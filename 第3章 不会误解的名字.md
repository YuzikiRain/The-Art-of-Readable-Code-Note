# 不好的例子

## Filter()

``` c++
results = Filter("year <= 2023");
```

并不知道筛选的结果是返回条件为true的部分，即年份<=2023还是条件为false的部分即>2023的。

这里的问题是"filter"是个二义性单词。我们不清楚它的含义到底是“挑出”还是“减掉”。最好避免使用"filter"这个名字，因为它太容易误解。

# 推荐的例子

## 推荐用min和max来表示（包含）极限

``` c++
int CART_TOO_BIG_LIMIT = 10
```

并不知道这个常量是表示最大数量应该<=10还是<10，而如果改为min或max，则能够明确地表示最大值最小值（闭区间，包含）

## 推荐用begin和end来表示包含/排除范围



## 给布尔值命名

``` c++
read = true
```

并不知道这个变量是表示需要读取还是已经读取。

加上像is、has、can或should这样的词，可以把布尔值变得更明确。

此外，最好避免使用反义词、反面表示，比如

``` c++
is_disable_ssl = false;
```

而是使用正面表示，以下同样表示使用

``` c++
is_enable_ssl = true;
```

# 与使用者的期望相匹配

### 先入为主

有些名字之所以会让人误解是因为用户对它们的含义有**先入为主的印象**，就算你的本意并非如此。

很多程序员都习惯了把以get开始的方法当做“**轻量级访问器**”这样的用法，它只是简单地返回一个内部成员变量。如果违背这个习惯很可能会误导用户。一个不好的例子：

``` c++
int GetStudentAmount()
{
    int amount = 0;
    for(auto student : students)
    {
        if (student.isValid) amount++;
    }
    return amount;
}

// 一些调用的场景
int studentAmount = 0;
for(auto class : classes)
{
    studentAmount += class.GetStudentAmount();
}
```

该函数总是会遍历整个集合，复杂度为O(n)而不是O(1)，如果有大量的数据的话，这样的一步可能会有很大的代价！比如这里又嵌套了一个循环，使得复杂度变为了O(n^2)而不是O(n)。但一个容易轻信的程序员可能会随意地调用，还以为这是个没什么代价的调用。

如果命名改为`CountMembers`等，用户很容易意识到这是一个耗时的函数。

### 向导是谁

一段时间以前，有位作者正在安装OpenBSD操作系统。在磁盘格式化这一步时，出现了一个复杂的菜单，询问磁盘参数。其中的一个选项是进入“向导模式”（Wizard mode）。他看到这个友好的选择松了一口气，并选择了它。让他失望的是，安装程序给出了低层命名行提示符等待手动输入磁盘格式化命令，而且也没有明显的方法可以退出。很明显，这里的“向导”指的是你自己。

我的理解是，对于程序设计者来说，使用“向导”这个词来表示用户是专业且准确的，但是他们没有注意到用户并不是和他们同一类人的程序员，而是小白，在用户视角只会将“向导”理解为领队、导游等。

# 如何权衡多个备选名字

当你要选一个好名字时，可能会同时考虑多个备选方案。通常你要在头脑中盘算一下每个名字的好处，然后才能得出最后的选择。

文中列举的例子可能在中文语义下不好理解。
